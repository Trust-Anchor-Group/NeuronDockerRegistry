using System.Collections.Generic;
using System.Threading.Tasks;
using TAG.Networking.DockerRegistry;
using Waher.IoTGateway;
using Waher.IoTGateway.WebResources;
using Waher.Networking.HTTP.Authentication;
using Waher.Networking.HTTP;
using Waher.Networking;
using Waher.Runtime.Inventory;
using Waher.Security.JWT;
using Waher.Security.Users;

namespace TAG.Service.DockerRegistry
{
	/// <summary>
	/// Service controlling the life-cycle of the Docker Registry
	/// </summary>
	public class RegistryService : IModule
	{
		private RegistryServerV2 server;

		/// <summary>
		/// Service controlling the life-cycle of the Docker Registry
		/// </summary>
		public RegistryService()
		{
		}

		/// <summary>
		/// Starts the service.
		/// </summary>
		public Task Start()
		{
			List<HttpAuthenticationScheme> Schemes = new List<HttpAuthenticationScheme>();

			if (Types.TryGetModuleParameter("JWT", out object Obj) &&
				Obj is JwtFactory JwtFactory &&
				!JwtFactory.Disposed)
			{
				Schemes.Add(new JwtAuthentication(Gateway.Domain, null, JwtFactory));   // Any JWT token generated by the server will suffice. Does not have to point to a registered user.
			}

			if (!(Gateway.HttpServer is null) && Gateway.HttpServer.ClientCertificates != ClientCertificates.NotUsed)
				Schemes.Add(new MutualTlsAuthentication(Users.Source));

			Schemes.Add(new BasicAuthentication(true, 128, Gateway.Domain, Users.Source));
			Schemes.Add(new DigestAuthentication(true, 128, DigestAlgorithm.MD5, Gateway.Domain, Users.Source));
			Schemes.Add(new DigestAuthentication(true, 128, DigestAlgorithm.SHA256, Gateway.Domain, Users.Source));
			Schemes.Add(new DigestAuthentication(true, 128, DigestAlgorithm.SHA3_256, Gateway.Domain, Users.Source));

			this.server = new RegistryServerV2(Schemes.ToArray());
			Gateway.HttpServer?.Register(this.server);

			return Task.CompletedTask;
		}

		/// <summary>
		/// Stops the service.
		/// </summary>
		public Task Stop()
		{
			Gateway.HttpServer?.Unregister(this.server);
			this.server = null;
	
			return Task.CompletedTask;
		}
	}
}
