using System.Collections.Generic;
using System.IO;
using System.Threading.Tasks;
using TAG.Networking.DockerRegistry;
using TAG.Networking.DockerRegistry.Model;
using Waher.Events;
using Waher.IoTGateway;
using Waher.IoTGateway.Setup;
using Waher.Networking;
using Waher.Networking.HTTP;
using Waher.Networking.HTTP.Authentication;
using Waher.Persistence;
using Waher.Persistence.Filters;
using Waher.Runtime.Inventory;
using Waher.Runtime.Timing;
using Waher.Security.JWT;
using Waher.Security.Users;
using Waher.Service.IoTBroker;
using Waher.Service.IoTBroker.DataStorage;

namespace TAG.Service.DockerRegistry
{
    /// <summary>
    /// Service controlling the life-cycle of the Docker Registry
    /// </summary>
    [Singleton]
    public class RegistryService : IConfigurableModule
    {
        private static RegistryService instance;

        private RegistryServerV2 server;
        private LiveStorageView liveStorageView;
        private Scheduler blobClearSchedule;
        public static RegistryService Instance => instance;

        /// <summary>
        /// Service controlling the life-cycle of the Docker Registry
        /// </summary>
        public RegistryService()
        {
            instance = this;
        }

        /// <summary>
        /// Starts the service.
        /// </summary>
        public Task Start()
        {
            List<HttpAuthenticationScheme> Schemes = new List<HttpAuthenticationScheme>();
            bool RequireEncryption;
            int MinSecurityStrength;

            if (DomainConfiguration.Instance.UseEncryption && !string.IsNullOrEmpty(DomainConfiguration.Instance.Domain))
            {
                RequireEncryption = true;
                MinSecurityStrength = 128;
            }
            else
            {
                RequireEncryption = false;
                MinSecurityStrength = 0;
            }

            if (Types.TryGetModuleParameter("JWT", out object Obj) &&
                Obj is JwtFactory JwtFactory &&
                !JwtFactory.Disposed)
            {
                Schemes.Add(new JwtAuthentication(RequireEncryption, MinSecurityStrength, Gateway.Domain, null, JwtFactory));   // Any JWT token generated by the server will suffice. Does not have to point to a registered user.
            }

            if (!(Gateway.HttpServer is null) && Gateway.HttpServer.ClientCertificates != ClientCertificates.NotUsed)
                Schemes.Add(new MutualTlsAuthentication(Users.Source));

            PersistenceLayer PersistanceLayer = XmppServerModule.PersistenceLayer ?? new PersistenceLayer();
            Schemes.Add(new BasicAuthentication(RequireEncryption, MinSecurityStrength, Gateway.Domain, new Accounts(PersistanceLayer)));
            Schemes.Add(new DigestAuthentication(RequireEncryption, MinSecurityStrength, DigestAlgorithm.MD5, Gateway.Domain, Users.Source));
            Schemes.Add(new DigestAuthentication(RequireEncryption, MinSecurityStrength, DigestAlgorithm.SHA256, Gateway.Domain, Users.Source));
            Schemes.Add(new DigestAuthentication(RequireEncryption, MinSecurityStrength, DigestAlgorithm.SHA3_256, Gateway.Domain, Users.Source));

            this.server = new RegistryServerV2(Path.Combine(Gateway.AppDataFolder, "DockerRegistry"), Schemes.ToArray());
            Gateway.HttpServer?.Register(this.server);

            this.liveStorageView = new LiveStorageView("/DockerRegistry/live-storage-view");
            Gateway.HttpServer?.Register(this.liveStorageView);

            blobClearSchedule = new Scheduler();
            CleanSchedule(null);

            Database.ObjectDeleted += async (object Sender, ObjectEventArgs args) =>
            {
                if (args.Object is DockerUser User)
                    await OnUserDeleted(User);
                else if (args.Object is DockerOrganization Organization)
                    await OnOrganizationDeleted(Organization);
                else if (args.Object is DockerRepository Repo)
                    await OnRepositoryDeleted(Repo);
                else if (args.Object is DanglingDockerBlob Blob)
                    await Blob.OnDanglingBlobDeleted();
            };

            Export.RegisterFolders("DockerRegistryBLOBs", "Docker Registry BLOBs", Path.Combine(Gateway.AppDataFolder, "DockerRegistry"));

            return Task.CompletedTask;
        }

        private async Task CleanSchedule(object State)
        {
            blobClearSchedule.Add(System.DateTime.Now.AddDays(1), CleanSchedule, null);

            await CleanUnmanagedRepositories();
            await CleanUnusedBlobs();
        }

        public async Task<int> CleanUnusedBlobs()
        {
            return await server.CleanUnusedBlobs();
        }

        public async Task<int> CleanUnmanagedRepositories()
        {
            return await server.CleanUnmanagedRepositories();
        }

        public async Task OnUserDeleted(DockerUser User)
        {
            await DeleteActorResources(User);
        }

        public async Task OnOrganizationDeleted(DockerOrganization Organization)
        {
            await DeleteActorResources(Organization);
        }

        public async Task DeleteActorResources(DockerActor Actor)
        {
            // delete owned repos
            await Database.FindDelete<DockerRepository>(new FilterAnd(new FilterFieldEqualTo("OwnerGuid", Actor.Guid)));
            // delete storage
            await Database.FindDelete<DockerRepository>(new FilterAnd(new FilterFieldEqualTo("OwnerGuid", Actor.Guid)));
            // delete all privileges
            await Database.FindDelete<DockerRepositoryPrivilege>(new FilterAnd(new FilterFieldEqualTo("ActorGuid", Actor.Guid)));
        }

        public async Task OnRepositoryDeleted(DockerRepository Repository)
        {
            // delete all images
            await Database.FindDelete<DockerImage>(new FilterAnd(new FilterFieldEqualTo("RepositoryName", Repository.RepositoryName)));
            // delete all privileges
            await Database.FindDelete<DockerRepositoryPrivilege>(new FilterAnd(new FilterFieldEqualTo("RepositoryGuid", Repository.Guid)));
        }

        /// <summary>
        /// Stops the service.
        /// </summary>
        public Task Stop()
        {
            if (!(this.server is null))
            {
                Gateway.HttpServer?.Unregister(this.server);
                this.server.Dispose();
                this.server = null;
            }

            if (!(this.liveStorageView is null))
            {
                Gateway.HttpServer?.Unregister(this.liveStorageView);
                this.liveStorageView.Dispose();
                this.liveStorageView = null;
            }

            return Task.CompletedTask;
        }

        public Task<IConfigurablePage[]> GetConfigurablePages()
        {
            return Task.FromResult(new IConfigurablePage[]
            {
                new ConfigurablePage("Docker Registry", "/DockerRegistry/Settings.md")
            });
        }
    }
}
